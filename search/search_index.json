{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MCP Security Analysis","text":""},{"location":"#executive-summary","title":"Executive Summary","text":"<p>This document provides an in-depth security analysis of the Model Context Protocol (MCP), reflecting the specification schema version <code>2025-03-26</code>, examining its core components, communication patterns, and trust boundaries based on the specification and reference implementations. The analysis aims to identify potential vulnerabilities and guide the secure development and deployment of MCP-based applications.</p> <p>MCP facilitates powerful integrations but introduces significant security considerations that must be addressed by implementers (Hosts, Clients, Servers), as the protocol itself cannot enforce many security guarantees. Key high-risk areas include:</p> <ol> <li>Tool Execution (<code>tools/call</code>): Represents a direct arbitrary code execution risk requiring rigorous server-side input validation, authorization, output sanitization, and strong client-side user confirmation.</li> <li>User Consent &amp; Control: The specification mandates, and secure implementation demands, explicit, informed user consent mediated by the Host/Client for actions like tool execution, sampling requests, and resource access. Failure here undermines the entire security model.</li> <li>Resource Access (<code>resources/read</code>, etc.): Requires meticulous server-side URI validation (preventing path traversal) and strict access control checks before serving resource data.</li> <li>Input Validation: Both Clients and Servers must rigorously validate all incoming parameters to prevent various injection attacks and denial-of-service.</li> <li>Sampling (<code>sampling/createMessage</code>): Exposes risks of prompt injection against the client's LLM and potential resource abuse (cost, rate limits) if not carefully controlled by the client with user oversight.</li> </ol> <p>Secure implementation requires adherence to principles like least privilege, defense-in-depth, secure defaults, transport security (HTTPS/WSS), robust authentication/authorization (e.g., OAuth 2.1/PKCE), careful data handling to prevent leakage (especially in logs and errors), and secure interaction with external systems. This analysis provides detailed recommendations and identifies specific control points across the protocol's features and trust boundaries.</p>"},{"location":"#1-introduction","title":"1. Introduction","text":"<p>This document provides a detailed analysis of the Model Context Protocol (MCP) focusing on its interactions, message types, data fields, potential extension points, data flows, trust boundaries, and communication patterns. The primary goal is to identify potential security considerations and attack surfaces within the MCP ecosystem to inform the development of the <code>mcp-security</code> project.</p> <p>Analysis is based on the <code>2025-03-26</code> version of the MCP specification (documented at modelcontextprotocol.io and defined in the <code>modelcontextprotocol/specification</code> repository) and insights from the reference implementations in the <code>modelcontextprotocol/servers</code> repository (covering TypeScript examples and the Python SDK). </p>"},{"location":"02-core-concepts/","title":"Core Concepts","text":""},{"location":"02-core-concepts/#2-core-concepts-based-on-specification-2025-03-26","title":"2. Core Concepts (Based on Specification <code>2025-03-26</code>)","text":"<p>MCP facilitates integration between LLM applications and external data sources/tools using JSON-RPC 2.0.</p>"},{"location":"02-core-concepts/#21-roles","title":"2.1. Roles","text":"<ul> <li>Host: The LLM application initiating connections (e.g., IDE, Chat Interface).</li> <li>Client: Connectors within the Host application, managing communication with specific Servers. Note: Often the Host acts as the Client.</li> <li>Server: Services providing context, tools, or capabilities to the Host/Client.</li> </ul>"},{"location":"02-core-concepts/#22-communication-foundation","title":"2.2. Communication Foundation","text":"<ul> <li>Protocol: JSON-RPC 2.0 over a suitable transport (e.g., WebSockets, stdio).</li> <li>State: Connections are stateful.</li> <li>Capabilities: Server and Client capabilities are negotiated during initialization.</li> </ul>"},{"location":"02-core-concepts/#23-key-features-provided-by-servers","title":"2.3. Key Features Provided by Servers","text":"<p>Servers can offer one or more of the following features:</p> <ul> <li>Resources: Contextual data for user or AI model consumption (e.g., files, database entries, web content).</li> <li>Prompts: Templated messages or predefined workflows presented to the user.</li> <li>Tools: Functions callable by the AI model, potentially executing code or interacting with external systems.</li> </ul>"},{"location":"02-core-concepts/#24-key-features-provided-by-clients","title":"2.4. Key Features Provided by Clients","text":"<p>Clients may offer the following feature to Servers:</p> <ul> <li>Sampling: Server-initiated requests for the Host/Client to perform LLM interactions (potentially recursive).</li> </ul>"},{"location":"02-core-concepts/#25-additional-utilities","title":"2.5. Additional Utilities","text":"<p>The protocol includes support for:</p> <ul> <li>Configuration management</li> <li>Progress tracking for long-running operations</li> <li>Request cancellation</li> <li>Standardized error reporting</li> <li>Logging</li> </ul>"},{"location":"02-core-concepts/#26-stated-security-principles-from-specification","title":"2.6. Stated Security Principles (from Specification)","text":"<p>The specification explicitly calls out the need for implementors to address security and trust, emphasizing:</p> <ul> <li>User Consent and Control: Explicit user understanding and approval for data access and actions. Clear UI/UX for authorization.</li> <li>Data Privacy: Explicit consent before exposing user data; protection of data.</li> <li>Tool Safety: Treat tools as arbitrary code execution paths. Verify descriptions. Explicit user consent before invocation.</li> <li>LLM Sampling Controls: Explicit user approval for sampling requests, control over prompts and result visibility.</li> </ul> <p>Note: The specification states MCP cannot enforce these principles at the protocol level and relies on implementors (<code>Host</code>, <code>Client</code>, <code>Server</code>) to build robust consent, authorization, and protection mechanisms. </p>"},{"location":"03-protocol-interactions/","title":"Protocol Interactions","text":""},{"location":"03-protocol-interactions/#3-protocol-interactions-message-deep-dive","title":"3. Protocol Interactions &amp; Message Deep Dive","text":"<p>This section details the fundamental JSON-RPC 2.0 message structures used by MCP, lifecycle management, and authorization basics.</p>"},{"location":"03-protocol-interactions/#31-base-message-structures-json-rpc-20","title":"3.1. Base Message Structures (JSON-RPC 2.0)","text":"<p>MCP uses standard JSON-RPC 2.0 for all messages. Key requirements and constraints:</p> <ul> <li>Requests:<ul> <li>Sent by either Client or Server to initiate an operation.</li> <li><code>jsonrpc</code>: \"2.0\"</li> <li><code>id</code>: <code>string</code> or <code>number</code> (Mandatory, MUST NOT be <code>null</code>). Request IDs must be unique per session for the sender.</li> <li><code>method</code>: <code>string</code> (Name of the method to be invoked).</li> <li><code>params</code>: <code>object</code> (Optional parameters for the method).</li> </ul> </li> <li>Responses:<ul> <li>Sent in reply to a Request.</li> <li><code>jsonrpc</code>: \"2.0\"</li> <li><code>id</code>: <code>string</code> or <code>number</code> (Must match the ID of the corresponding Request).</li> <li><code>result</code>: <code>object</code> (Present on success, contains the operation result).</li> <li><code>error</code>: <code>object</code> (Present on failure). Must contain <code>code</code> (<code>integer</code>), <code>message</code> (<code>string</code>), and optionally <code>data</code> (<code>unknown</code>).</li> <li>A response MUST contain either <code>result</code> or <code>error</code>, but not both.</li> </ul> </li> <li>Notifications:<ul> <li>Sent by either Client or Server as a one-way message (no response expected).</li> <li><code>jsonrpc</code>: \"2.0\"</li> <li><code>method</code>: <code>string</code> (Name of the notification event).</li> <li><code>params</code>: <code>object</code> (Optional parameters for the notification).</li> <li>MUST NOT include an <code>id</code>.</li> </ul> </li> <li>Batching:<ul> <li>Implementations MUST support receiving batched requests/notifications (sent as a JSON array).</li> <li>Implementations MAY support sending batches.</li> </ul> </li> </ul> <p>Security Considerations (Base JSON-RPC):</p> <ul> <li>Request ID Uniqueness: While mandated, improper handling could lead to response mismatches or potential replay attacks if IDs are predictable or reused insecurely within a session.</li> <li>Error Handling: Sensitive information could be leaked in <code>error</code> messages (<code>message</code> or <code>data</code> fields) if not carefully constructed.</li> <li>Batching Complexity: Handling batches correctly is crucial. Errors in processing one part of a batch should not necessarily halt others, but error reporting needs to be precise. Large batches could be used for DoS attempts.</li> </ul>"},{"location":"03-protocol-interactions/#32-lifecycle-management-initialize-shutdown-exit","title":"3.2. Lifecycle Management (Initialize, Shutdown, Exit)","text":"<p>The connection follows a defined lifecycle:</p> <ol> <li>Initialization Phase:<ul> <li>Trigger: Client sends <code>initialize</code> request to Server.</li> <li>Purpose: Negotiate protocol version, exchange capabilities, share implementation info (<code>clientInfo</code>, <code>serverInfo</code>).</li> <li>Client <code>initialize</code> Params: <code>protocolVersion</code>, <code>capabilities</code> (Client's offered features like <code>roots</code>, <code>sampling</code>), <code>clientInfo</code> (<code>name</code>, <code>version</code>).</li> <li>Server <code>initialize</code> Result: <code>protocolVersion</code> (Agreed version), <code>capabilities</code> (Server's offered features like <code>logging</code>, <code>prompts</code>, <code>resources</code>, <code>tools</code>), <code>serverInfo</code> (<code>name</code>, <code>version</code>).</li> <li>Protocol Version Negotiation: Client proposes version (latest supported). Server responds with the same version if supported, otherwise its latest supported version. Client SHOULD disconnect if server's version is unsupported.</li> <li>Capability Negotiation: Defines which optional features (Resources, Tools, Prompts, Sampling, Logging, Roots, etc.) are available for the session. Specific sub-capabilities (e.g., <code>listChanged</code>, <code>subscribe</code>) are also negotiated here.</li> <li>Confirmation: Client sends <code>notifications/initialized</code> notification after receiving a successful <code>initialize</code> response.</li> <li>Restrictions:<ul> <li><code>initialize</code> request MUST NOT be batched.</li> <li>Client SHOULD NOT send other requests (except ping) before server responds to <code>initialize</code>.</li> <li>Server SHOULD NOT send requests (except ping, logging) before receiving <code>notifications/initialized</code>.</li> </ul> </li> </ul> </li> <li>Operation Phase:<ul> <li>Normal exchange of requests, responses, and notifications based on negotiated capabilities and protocol version.</li> </ul> </li> <li>Shutdown Phase:<ul> <li>Clean termination initiated usually by the Client.</li> <li>No specific protocol messages.</li> <li>Relies on transport layer closure (e.g., closing stdio streams, closing HTTP connections).</li> <li>Specification provides guidance for graceful shutdown with stdio (close input, wait/SIGTERM, wait/SIGKILL).</li> </ul> </li> </ol> <p>Security Considerations (Lifecycle):</p> <ul> <li>Initialization Vulnerabilities:<ul> <li>Capability Spoofing/Misrepresentation: A malicious Client or Server could lie about its <code>capabilities</code> or <code>Info</code>, potentially tricking the other party into insecure operations or attempting to enable features it doesn't securely support.</li> <li>Version Downgrade Attacks: If negotiation logic isn't strict, an attacker might force the use of an older, potentially less secure protocol version.</li> <li>Resource Exhaustion during Init: A flood of <code>initialize</code> requests or large capability objects could cause DoS.</li> <li>Information Leakage: <code>clientInfo</code> and <code>serverInfo</code> could leak potentially sensitive details about the software versions in use, aiding attackers in finding known exploits.</li> </ul> </li> <li>Improper Shutdown: Failure to shut down gracefully (especially with stdio) could leave orphaned server processes, potentially consuming resources or holding locks.</li> <li>State Mismatches: If the <code>notifications/initialized</code> is lost or mishandled, the Client and Server might have different understandings of the session state, leading to errors or unexpected behavior.</li> <li>Capability Enforcement: The protocol relies on implementations to honor the negotiated capabilities. A compromised or malicious participant could ignore the negotiation and attempt to use features that weren't agreed upon.</li> </ul>"},{"location":"03-protocol-interactions/#33-authorization-http-transport","title":"3.3. Authorization (HTTP Transport)","text":"<p>Authorization is optional but specified for HTTP-based transports. Implementations using stdio SHOULD retrieve credentials from the environment instead.</p> <ul> <li>Standard: Based on OAuth 2.1 (IETF Draft) with PKCE mandatory for all clients.</li> <li>Trigger: Server responds with HTTP 401 Unauthorized when authorization is required.</li> <li>Flow: Standard OAuth 2.1 Authorization Code Grant flow with PKCE.<ol> <li>Client receives 401.</li> <li>Client generates <code>code_verifier</code> and <code>code_challenge</code>.</li> <li>Client directs user-agent (browser) to Server's authorization endpoint (<code>/authorize</code> by default, or discovered via metadata) with <code>code_challenge</code>.</li> <li>User authenticates and authorizes the Client via the Server.</li> <li>Server redirects user-agent back to Client's registered <code>redirect_uri</code> with an <code>authorization_code</code>.</li> <li>Client receives <code>authorization_code</code>.</li> <li>Client makes a POST request to the Server's token endpoint (<code>/token</code> by default, or discovered) including the <code>authorization_code</code> and the original <code>code_verifier</code>.</li> <li>Server verifies the code and verifier, issues an <code>access_token</code> (and optionally a <code>refresh_token</code>).</li> <li>Client includes the <code>access_token</code> in the <code>Authorization: Bearer &lt;token&gt;</code> header for subsequent MCP requests over HTTP.</li> </ol> </li> <li>Metadata Discovery (RFC 8414):<ul> <li>Clients MUST attempt discovery via <code>GET /.well-known/oauth-authorization-server</code> relative to the authorization base URL (Server URL with path removed).</li> <li>Clients SHOULD include <code>MCP-Protocol-Version</code> header in discovery requests.</li> <li>Servers SHOULD provide metadata; if not, Clients MUST fallback to default paths (<code>/authorize</code>, <code>/token</code>, <code>/register</code>).</li> </ul> </li> <li>Dynamic Client Registration (RFC 7591):<ul> <li>Clients and Servers SHOULD support dynamic registration via the registration endpoint (<code>/register</code> by default or discovered).</li> <li>Allows clients to obtain <code>client_id</code> (and potentially <code>client_secret</code> for confidential clients) automatically.</li> <li>Servers not supporting it require alternative methods (hardcoded ID, manual user entry).</li> </ul> </li> <li>Access Token Usage:<ul> <li>MUST be sent in <code>Authorization: Bearer &lt;token&gt;</code> header for every HTTP request.</li> <li>MUST NOT be sent in URI query string.</li> <li>Servers MUST validate tokens (signature, expiry, scope) and respond with 401/403 on failure.</li> </ul> </li> <li>Third-Party Authorization: Servers MAY delegate auth to a third-party OAuth server, acting as a client to the third-party and an authorization server to the MCP client. Requires careful session binding and validation.</li> </ul> <p>Security Considerations (Authorization):</p> <ul> <li>Transport Security: All authorization endpoints MUST use HTTPS.</li> <li>PKCE Implementation: Correct implementation is crucial to prevent authorization code interception attacks.</li> <li>Redirect URI Validation: Servers MUST strictly validate <code>redirect_uri</code> against pre-registered values to prevent Open Redirect attacks and token leakage.</li> <li>Token Storage (Client): Clients MUST store access and refresh tokens securely (e.g., using OS keychain, encrypted storage).</li> <li>Token Handling (Server): Servers SHOULD enforce short token lifetimes, support token rotation (refresh tokens), and securely validate tokens.</li> <li>Dynamic Client Registration Security: Unauthenticated or improperly secured registration endpoints could allow malicious clients to register. Servers need robust policies.</li> <li>Metadata Security: Relying on potentially unsecured HTTP for discovery (if HTTPS is not enforced) could lead to endpoint spoofing.</li> <li>Third-Party Auth Risks: Introduces complexity and reliance on the third-party's security. Session binding must be robust to prevent attacks where a compromised third-party session grants access to MCP.</li> <li>Scope Management: Proper definition and enforcement of OAuth scopes are needed to limit the client's access to only what the user authorized (least privilege).</li> <li>Credential Handling (stdio): Retrieving credentials from the environment for stdio transport needs careful handling to avoid exposing secrets in logs, process lists, or insecure environment variable storage. </li> </ul>"},{"location":"04-data-structures/","title":"Data Structures","text":""},{"location":"04-data-structures/#4-data-structures-fields","title":"4. Data Structures &amp; Fields","text":"<p>This section analyzes the core data structures exchanged via MCP.</p>"},{"location":"04-data-structures/#41-capabilities","title":"4.1. Capabilities","text":"<ul> <li>Structure: Nested objects declared during <code>initialize</code>. Top-level keys indicate features (<code>resources</code>, <code>tools</code>, <code>prompts</code>, <code>sampling</code>, <code>logging</code>, <code>roots</code>, <code>experimental</code>). Inner keys indicate sub-features (e.g., <code>resources: { subscribe: boolean, listChanged: boolean }</code>).</li> <li>Purpose: Define the contract for the session.</li> <li>Security Considerations:<ul> <li>Misinterpretation: Ambiguity in capability definitions could lead to differing implementations and unexpected behavior.</li> <li>Over-declaration: A client/server might declare support for features it doesn't handle securely.</li> <li>Granularity: Capabilities might not be granular enough to express fine-grained permissions (e.g., allowing <code>resources/list</code> but not <code>resources/read</code> for certain resource types). Authorization (Section 3.3) is the primary mechanism here, but capabilities set the stage.</li> <li>Experimental Features: The <code>experimental</code> capability is inherently risky; features under it may be unstable, insecure, or change without notice. Use requires explicit opt-in and understanding of risks.</li> </ul> </li> </ul>"},{"location":"04-data-structures/#42-resources","title":"4.2. Resources","text":"<ul> <li>Purpose: Represent contextual data (files, web content, database info, etc.).</li> <li>Key Methods:<ul> <li><code>resources/list</code>: Discover available resources (supports pagination).</li> <li><code>resources/read</code>: Retrieve the content of a specific resource by URI.</li> <li><code>resources/templates/list</code>: Discover parameterized resource templates (URI Templates RFC6570).</li> <li><code>resources/subscribe</code>: (Optional) Client subscribes to updates for a specific resource URI.</li> <li><code>notifications/resources/list_changed</code>: (Optional) Server notifies client that the list of resources has changed.</li> <li><code>notifications/resources/updated</code>: (Optional) Server notifies client that a subscribed resource has changed.</li> </ul> </li> <li>Resource Object:<ul> <li><code>uri</code>: <code>string</code> (Unique identifier, e.g., <code>file:///</code>, <code>https://</code>, <code>git://</code>, custom schemes).</li> <li><code>name</code>: <code>string</code> (Human-readable).</li> <li><code>description</code>: <code>string</code> (Optional).</li> <li><code>mimeType</code>: <code>string</code> (Optional, e.g., <code>text/plain</code>, <code>image/png</code>, <code>application/json</code>).</li> <li><code>size</code>: <code>number</code> (Optional, bytes).</li> </ul> </li> <li>Resource Content Object (in <code>resources/read</code> result):<ul> <li><code>uri</code>: <code>string</code>.</li> <li><code>mimeType</code>: <code>string</code>.</li> <li><code>text</code>: <code>string</code> (Mutually exclusive with <code>blob</code>).</li> <li><code>blob</code>: <code>string</code> (Base64 encoded binary data, mutually exclusive with <code>text</code>).</li> </ul> </li> <li>Resource Template Object:<ul> <li><code>uriTemplate</code>: <code>string</code> (RFC6570 URI Template).</li> <li><code>name</code>: <code>string</code>.</li> <li><code>description</code>: <code>string</code>.</li> <li><code>mimeType</code>: <code>string</code>.</li> </ul> </li> <li>Security Considerations:<ul> <li>URI Handling &amp; Path Traversal: Servers MUST rigorously validate and sanitize incoming URIs (<code>resources/read</code>, <code>resources/subscribe</code>) to prevent path traversal attacks (e.g., <code>file:///../../../etc/passwd</code>). Canonicalize paths and enforce base directory restrictions. Custom URI schemes need equally robust validation.</li> <li>Access Control: Servers MUST check authorization before listing (<code>resources/list</code>) or reading (<code>resources/read</code>) resources. Sensitive resources should not be listed or readable without proper permissions.</li> <li>Data Leakage: Listing resources (<code>resources/list</code>) might inadvertently leak existence or metadata (name, description, mimeType) of sensitive files/data even if content access is restricted. Consider filtering lists based on permissions.</li> <li>Large Resource DoS: A request for a very large resource (<code>resources/read</code>) could cause DoS on the server (memory exhaustion) or client. Servers SHOULD implement size limits and potentially streaming responses (though streaming isn't explicit in the base spec). Clients should also have limits.</li> <li>Subscription Storms: Malicious clients could subscribe (<code>resources/subscribe</code>) to many resources or resources that change frequently, causing excessive notifications (<code>notifications/resources/updated</code>) and server load. Rate limiting or subscription limits are needed.</li> <li>Insecure Content Handling (Client): Clients receiving resource content (<code>text</code> or <code>blob</code>) must handle it safely based on the <code>mimeType</code>. Displaying HTML/JS content unsanitized could lead to XSS. Executing binary content is risky.</li> <li>URI Template Injection: If server-side logic constructs <code>uriTemplate</code> values based on user input without sanitization, it could lead to injection vulnerabilities allowing unintended resource access patterns. Templates themselves should be validated. Client-side expansion of templates also needs care.</li> <li>Base64 Bombs: Maliciously crafted large base64 <code>blob</code> data could cause DoS when decoded by the client or server. Implement size limits before decoding.</li> <li>MIME Type Spoofing: A malicious server could provide a misleading <code>mimeType</code> (e.g., <code>text/plain</code> for malicious HTML) to trick the client into unsafe handling. Clients should be cautious and potentially validate content against the claimed type.</li> </ul> </li> </ul>"},{"location":"04-data-structures/#43-tools","title":"4.3. Tools","text":"<ul> <li>Purpose: Represent functions callable by the AI model, enabling interaction with external systems.</li> <li>Key Methods:<ul> <li><code>tools/list</code>: Discover available tools (supports pagination).</li> <li><code>tools/call</code>: Invoke a specific tool by name with arguments.</li> <li><code>notifications/tools/list_changed</code>: (Optional) Server notifies client that the list of tools has changed.</li> </ul> </li> <li>Tool Object:<ul> <li><code>name</code>: <code>string</code> (Unique identifier).</li> <li><code>description</code>: <code>string</code> (Human-readable, intended for LLM).</li> <li><code>inputSchema</code>: <code>object</code> (JSON Schema defining expected arguments).</li> <li><code>annotations</code>: <code>object</code> (Optional, untrusted metadata about tool behavior).</li> </ul> </li> <li>Tool Call Params:<ul> <li><code>name</code>: <code>string</code>.</li> <li><code>arguments</code>: <code>object</code> (Arguments matching the tool's <code>inputSchema</code>).</li> </ul> </li> <li>Tool Call Result:<ul> <li><code>content</code>: <code>array</code> (List of content items: <code>text</code>, <code>image</code>, <code>audio</code>, <code>resource</code>).</li> <li><code>isError</code>: <code>boolean</code> (Indicates if the tool execution failed, distinct from protocol errors).</li> </ul> </li> <li>Security Considerations:<ul> <li>Arbitrary Code Execution Risk: Tools fundamentally represent potential code execution on the server or interaction with external APIs. This is the highest-risk feature.</li> <li>Input Validation: Servers MUST rigorously validate <code>arguments</code> against the <code>inputSchema</code> before executing the tool logic. This prevents injection attacks (SQLi, command injection, etc.) within the tool implementation. Use established JSON Schema validation libraries.</li> <li>Access Control: Servers MUST check if the client (and underlying user) is authorized to call the specific tool (<code>tools/call</code>) and potentially with the given arguments.</li> <li>Output Sanitization: Tool results (<code>content</code>) returned to the client MUST be sanitized, especially <code>text</code> content. If results include user-generated or external API data, it could contain malicious scripts (XSS) if rendered directly by the client/host UI. Base64 <code>blob</code> data for images/audio also needs size validation. Embedded <code>resource</code> content inherits resource security considerations.</li> <li>Untrusted Descriptions/Annotations: Clients/Hosts MUST treat <code>description</code> and <code>annotations</code> as potentially misleading, especially if the server isn't fully trusted. The LLM might be tricked into calling a harmful tool based on a false description. User confirmation is critical.</li> <li>Data Exfiltration via Arguments: The LLM (prompted by a malicious user or compromised) could attempt to exfiltrate sensitive data available in its context by placing it into the <code>arguments</code> of a <code>tools/call</code>. Clients/Hosts SHOULD review arguments before sending or implement data loss prevention (DLP).</li> <li>Tool Chaining Attacks: Complex interactions involving multiple tool calls could lead to unexpected states or vulnerabilities.</li> <li>Denial of Service: Malicious clients could call tools repeatedly (<code>tools/call</code>) or provide arguments causing excessive computation or external API calls. Rate limiting per-user/per-client/per-tool is essential.</li> <li>Error Reporting: Tool execution errors (<code>isError: true</code>) should not leak sensitive internal details in the returned <code>content</code>.</li> </ul> </li> </ul>"},{"location":"04-data-structures/#44-prompts","title":"4.4. Prompts","text":"<ul> <li>Purpose: Provide structured, templated messages/instructions, often user-initiated (e.g., slash commands).</li> <li>Key Methods:<ul> <li><code>prompts/list</code>: Discover available prompts (supports pagination).</li> <li><code>prompts/get</code>: Retrieve a specific prompt's content, optionally providing arguments for customization.</li> <li><code>notifications/prompts/list_changed</code>: (Optional) Server notifies client that the list of prompts has changed.</li> </ul> </li> <li>Prompt Object:<ul> <li><code>name</code>: <code>string</code> (Unique identifier).</li> <li><code>description</code>: <code>string</code> (Optional, human-readable).</li> <li><code>arguments</code>: <code>array</code> (Optional, list of argument definitions: <code>name</code>, <code>description</code>, <code>required</code>).</li> </ul> </li> <li>Prompt Get Params:<ul> <li><code>name</code>: <code>string</code>.</li> <li><code>arguments</code>: <code>object</code> (Optional, values for defined arguments).</li> </ul> </li> <li>Prompt Get Result:<ul> <li><code>description</code>: <code>string</code>.</li> <li><code>messages</code>: <code>array</code> (List of <code>PromptMessage</code> objects).</li> </ul> </li> <li>PromptMessage Object:<ul> <li><code>role</code>: <code>string</code> (<code>user</code> or <code>assistant</code>).</li> <li><code>content</code>: <code>object</code> (Can be <code>text</code>, <code>image</code>, <code>audio</code>, or <code>resource</code>). Content structure matches tool results/resource contents.</li> </ul> </li> <li>Security Considerations:<ul> <li>Argument Injection: If the server generates the <code>messages</code> in the <code>prompts/get</code> response by inserting provided <code>arguments</code> into templates without proper sanitization, it could lead to injection attacks (e.g., injecting control characters, prompt injection payloads within arguments). Servers MUST sanitize arguments before using them in templates.</li> <li>Access Control: Servers should ensure the client is authorized to list (<code>prompts/list</code>) or get (<code>prompts/get</code>) specific prompts, especially if prompts could expose sensitive information or workflows.</li> <li>Data Exposure in Prompts: Prompt templates themselves or the results of <code>prompts/get</code> (after argument insertion) might contain sensitive information if not designed carefully.</li> <li>Misleading Prompts: Similar to tool descriptions, a malicious server could provide prompts (<code>description</code> or <code>messages</code>) designed to trick the user or LLM into unsafe actions.</li> <li>Resource Handling: Embedded <code>resource</code> content within prompt messages inherits all security considerations from Section 4.2. Servers must ensure arguments don't lead to unauthorized resource embedding. Clients must handle received resources safely.</li> <li>Complexity/DoS: Very complex prompts or prompts requiring extensive server-side processing based on arguments could lead to DoS.</li> </ul> </li> </ul>"},{"location":"04-data-structures/#45-sampling-client-feature","title":"4.5. Sampling (Client Feature)","text":"<ul> <li>Purpose: Allows Servers to request LLM generation (completion) from the Client/Host.</li> <li>Capability: Client declares <code>sampling: {}</code>.</li> <li>Key Method:<ul> <li><code>sampling/createMessage</code> (Server -&gt; Client Request): Requests the client to generate a message using its LLM.</li> </ul> </li> <li>Request Params (<code>sampling/createMessage</code>):<ul> <li><code>messages</code>: <code>array</code> (List of <code>PromptMessage</code> objects, similar to <code>prompts/get</code> result, forming the context/prompt).</li> <li><code>modelPreferences</code>: <code>object</code> (Optional hints for model selection: <code>hints</code> (array of <code>{name: string}</code>), <code>costPriority</code>, <code>speedPriority</code>, <code>intelligencePriority</code> (all 0-1)).</li> <li><code>systemPrompt</code>: <code>string</code> (Optional).</li> <li><code>maxTokens</code>: <code>number</code> (Optional).</li> </ul> </li> <li>Result (<code>sampling/createMessage</code>):<ul> <li><code>role</code>: <code>string</code> (Usually <code>assistant</code>).</li> <li><code>content</code>: <code>object</code> (The generated content: <code>text</code>, <code>image</code>, <code>audio</code>).</li> <li><code>model</code>: <code>string</code> (Identifier of the model used by the client).</li> <li><code>stopReason</code>: <code>string</code> (Reason generation stopped, e.g., <code>endTurn</code>, <code>maxTokens</code>).</li> </ul> </li> <li>Security Considerations:<ul> <li>User Consent &amp; Control (CRITICAL): As the spec strongly recommends, Clients MUST implement robust user confirmation before sending the request to the LLM and potentially before returning the response to the Server. Users should be able to view/edit the prompt.</li> <li>Prompt Injection from Server: The <code>messages</code> and <code>systemPrompt</code> provided by the Server could contain malicious instructions intended to manipulate the Client's LLM or exfiltrate data from the Client's context if the Client blindly concatenates them with other data before sending to the LLM.</li> <li>Resource Consumption (Client-Side): Malicious Servers could send frequent or computationally expensive <code>sampling/createMessage</code> requests, causing high LLM costs or resource usage on the Client side. Clients MUST implement rate limiting and potentially cost controls.</li> <li>Data Leakage in Prompts: Sensitive information from the Server's context could be included in the <code>messages</code> sent to the Client. While the Client controls LLM access, this data is still exposed to the Client application and potentially the user.</li> <li>Data Leakage in Responses: The LLM's response (<code>content</code>) might contain sensitive information (either hallucinated or derived from sensitive training data) which is then sent back to the Server. Clients might need to filter/review responses.</li> <li>Model Selection Manipulation: A malicious Server might use <code>modelPreferences</code> to try and force the Client to use a less secure or less capable model, although the Client has final control.</li> <li>Content Validation: Both Client and Server should validate the content (<code>text</code>, <code>image</code>, <code>audio</code>) received to prevent attacks (e.g., Base64 bombs, malicious media files).</li> </ul> </li> </ul>"},{"location":"04-data-structures/#46-roots-client-feature","title":"4.6. Roots (Client Feature)","text":"<ul> <li>Purpose: Allows Clients to inform Servers about the accessible filesystem root directories (workspaces, projects).</li> <li>Capability: Client declares <code>roots: { listChanged: boolean }</code>.</li> <li>Key Methods:<ul> <li><code>roots/list</code> (Server -&gt; Client Request): Server asks the Client for the list of roots.</li> <li><code>notifications/roots/list_changed</code>: (Optional) Client notifies Server that the list of roots has changed.</li> </ul> </li> <li>Root Object:<ul> <li><code>uri</code>: <code>string</code> (MUST be a <code>file://</code> URI).</li> <li><code>name</code>: <code>string</code> (Optional, human-readable).</li> </ul> </li> <li>Security Considerations:<ul> <li>Information Disclosure: Exposing root URIs (<code>roots/list</code>) reveals filesystem structure information to the Server. Clients MUST ensure only intended roots are exposed, ideally with user consent per root.</li> <li>Insecure Root Exposure: Clients MUST NOT expose sensitive directories (e.g., <code>/</code>, <code>C:\\</code>, system folders, user profile root) unless explicitly intended and understood by the user.</li> <li>URI Validation (Client): Clients MUST validate the URIs they expose to ensure they are well-formed <code>file://</code> URIs and correspond to actual, intended locations. Path traversal issues are less likely here (as the client provides the roots) but validation is still good practice.</li> <li>Server Misuse of Roots: Servers receive the root list as information. They MUST respect these boundaries when constructing resource URIs (e.g., for <code>resources/read</code>). A malicious Server might ignore the roots and try to access files outside them (<code>file:///etc/passwd</code>), relying on the Server's own access control for resources (see Section 4.2) to prevent this. The <code>roots</code> mechanism itself is primarily informational for the server.</li> <li>Race Conditions: If roots change (<code>notifications/roots/list_changed</code>) while a Server is performing operations based on the old list, inconsistencies could occur. Servers need to handle updates gracefully.</li> </ul> </li> </ul>"},{"location":"04-data-structures/#47-utility-features","title":"4.7. Utility Features","text":"<p>Summarizes miscellaneous protocol utilities and their security aspects.</p> <ul> <li>Pagination (<code>resources/list</code>, <code>tools/list</code>, <code>prompts/list</code>, etc.):<ul> <li>Mechanism: Opaque <code>cursor</code> in request params, <code>nextCursor</code> in results.</li> <li>Security: Cursors MUST be treated as opaque by clients. Servers MUST validate received cursors to prevent unauthorized access to data or information disclosure if cursors encode state/permissions insecurely. Servers should ensure cursors expire or are session-bound.</li> </ul> </li> <li>Cancellation (<code>notifications/cancelled</code>):<ul> <li>Mechanism: Notification sent by request initiator with <code>requestId</code> to cancel.</li> <li>Security: Primarily a functional concern. Malicious cancellation floods could cause minor DoS. Receivers MUST validate that the <code>requestId</code> corresponds to an active request they received to prevent cross-request interference (though the impact is likely low).</li> </ul> </li> <li>Progress (<code>notifications/progress</code>):<ul> <li>Mechanism: Request includes <code>_meta: { progressToken: ... }</code>. Receiver sends notifications with token and progress values (<code>progress</code>, <code>total</code>, <code>message</code>).</li> <li>Security: <code>progressToken</code> uniqueness must be enforced by the sender of the original request. Receivers should validate tokens correspond to active requests. Sensitive information MUST NOT be leaked in the <code>message</code> field of the progress notification. Progress notification floods could cause minor DoS.</li> </ul> </li> <li>Ping (<code>ping</code> request):<ul> <li>Mechanism: Simple request/response to check liveness.</li> <li>Security: Minimal risk. Potential for minor DoS via ping floods if not rate-limited (though less likely to be effective than other methods). Primarily used for connection health.</li> </ul> </li> <li>Logging (<code>notifications/message</code>, <code>logging/setLevel</code> request):<ul> <li>Mechanism: Server sends log notifications (<code>level</code>, <code>logger</code>, <code>data</code>). Client can optionally set minimum <code>level</code>.</li> <li>Security (CRITICAL): Log data (<code>params.data</code>) MUST NOT contain sensitive information (credentials, PII, internal system details). Servers MUST sanitize logs before sending. Clients should be careful about displaying raw log data that might contain control characters or other harmful content. Log flooding could cause DoS on the client.</li> </ul> </li> <li>Completion (<code>completion/complete</code> request):<ul> <li>Mechanism: Client requests suggestions for prompt/resource arguments (<code>ref</code>, <code>argument</code> { <code>name</code>, <code>value</code> }). Server responds with suggestions (<code>values</code>, <code>total</code>, <code>hasMore</code>).</li> <li>Security: Server MUST validate <code>ref</code> and <code>argument.name</code> to ensure client is authorized to get completions for that item/argument. Suggestions (<code>values</code>) returned by the server MUST NOT leak sensitive information (e.g., suggesting private filenames, user data). Server should rate-limit completion requests. Clients should sanitize suggestions before display.</li> </ul> </li> </ul>"},{"location":"05-communication-patterns/","title":"Communication Patterns","text":""},{"location":"05-communication-patterns/#5-communication-patterns-data-flow","title":"5. Communication Patterns &amp; Data Flow","text":"<p>This section illustrates typical sequences of message exchanges for key MCP operations. These flows highlight how different protocol features interact.</p>"},{"location":"05-communication-patterns/#51-initialization-capability-negotiation","title":"5.1. Initialization &amp; Capability Negotiation","text":"<p>This is the mandatory first step after establishing the underlying transport connection (e.g., TCP, WebSocket, stdio pipe).</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Transport Connection Established\n\n    Client-&gt;&gt;+Server: 1. Request: initialize\n    Note right of Client: Sends clientInfo, supported protocolVersion(s), client Capabilities (e.g., sampling, roots)\n\n    Server--&gt;&gt;-Client: 2. Response: initialize (result or error)\n    Note left of Server: Sends serverInfo, agreed protocolVersion, server Capabilities (e.g., resources, tools, prompts, logging)\n\n    opt Successful Initialization\n        Client-&gt;&gt;+Server: 3. Notification: notifications/initialized\n        Note right of Client: Signals readiness for normal operation\n        Server--&gt;&gt;-Client: (Ready for normal operation)\n    end\n\n    Note over Client,Server: Operation Phase Begins (if successful)\n</code></pre> <p>Flow Description:</p> <ol> <li>Client -&gt; Server (<code>initialize</code> Request): The client initiates the handshake, declaring its identity (<code>clientInfo</code>), the protocol version(s) it supports, and the capabilities it offers (e.g., <code>sampling</code>, <code>roots</code>).</li> <li>Server -&gt; Client (<code>initialize</code> Response): The server responds with its identity (<code>serverInfo</code>), the protocol version it agrees to use for the session (based on mutual support), and the capabilities it offers (e.g., <code>resources</code>, <code>tools</code>). If initialization fails (e.g., version mismatch, critical error), it returns an error response.</li> <li>Client -&gt; Server (<code>notifications/initialized</code> Notification): Upon receiving a successful <code>initialize</code> response, the client confirms it's ready to proceed with normal operations according to the negotiated capabilities and protocol version.</li> </ol> <p>Security Implications: See Section 3.2 for detailed security considerations related to this phase (Capability Spoofing, Version Downgrade, Info Leakage, etc.). The integrity and validation of this initial exchange are critical for session security.</p>"},{"location":"05-communication-patterns/#52-resource-discovery-reading","title":"5.2. Resource Discovery &amp; Reading","text":"<p>This pattern describes how a client finds available resources and retrieves the content of one.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n\n    Note over Client,Server: Assumes successful initialization and 'resources' capability negotiated.\n\n    Client-&gt;&gt;+Server: 1. Request: resources/list\n    Note right of Client: Optionally includes 'cursor' for pagination.\n\n    Server--&gt;&gt;-Client: 2. Response: resources/list (result)\n    Note left of Server: Contains a page of 'Resource' objects and potentially 'nextCursor'.\n\n    Note over Client: User/Client selects a specific resource URI from the list (e.g., \"file:///data/item.txt\")\n\n    Client-&gt;&gt;+Server: 3. Request: resources/read\n    Note right of Client: Params include the selected 'uri'.\n\n    Server--&gt;&gt;-Client: 4. Response: resources/read (result or error)\n    Note left of Server: On success, contains 'Resource Content' object (with 'text' or 'blob'). On failure, returns error (e.g., Not Found, Access Denied).\n\n</code></pre> <p>Flow Description:</p> <ol> <li>Client -&gt; Server (<code>resources/list</code> Request): The client requests a list of available resources. It may include a <code>cursor</code> obtained from a previous response to fetch subsequent pages.</li> <li>Server -&gt; Client (<code>resources/list</code> Response): The server returns a list (potentially a page) of <code>Resource</code> objects it deems accessible/relevant to the client, potentially including a <code>nextCursor</code> if more results exist. Authorization checks should happen server-side before returning results.</li> <li>Client -&gt; Server (<code>resources/read</code> Request): After identifying a desired resource (e.g., via user selection, application logic), the client requests its content using the resource's <code>uri</code>.</li> <li>Server -&gt; Client (<code>resources/read</code> Response): The server performs access control checks for the requested <code>uri</code>. If authorized and the resource exists, it returns the <code>Resource Content</code> (containing the actual data as <code>text</code> or <code>blob</code>). Otherwise, it returns an appropriate JSON-RPC error.</li> </ol> <p>Security Implications: See Section 4.2 for detailed considerations: - Crucial server-side validation of URIs in <code>resources/read</code> to prevent path traversal. - Access control enforcement before both listing and reading. - Potential data leakage via metadata in <code>resources/list</code> results. - Safe handling of received content (<code>text</code>/<code>blob</code>) by the client. - Potential DoS via large resource requests or pagination abuse.</p>"},{"location":"05-communication-patterns/#53-tool-discovery-execution","title":"5.3. Tool Discovery &amp; Execution","text":"<p>This pattern shows how a client discovers available tools and invokes one, often guided by an LLM or user interaction.</p> <pre><code>sequenceDiagram\n    participant User/LLM\n    participant Client\n    participant Server\n\n    Note over Client,Server: Assumes successful initialization and 'tools' capability negotiated.\n\n    Client-&gt;&gt;+Server: 1. Request: tools/list\n    Note right of Client: Optionally includes 'cursor' for pagination.\n\n    Server--&gt;&gt;-Client: 2. Response: tools/list (result)\n    Note left of Server: Contains a page of 'Tool' objects (name, description, inputSchema) and potentially 'nextCursor'.\n\n    Note over User/LLM, Client: Tool selection occurs.\n    Note over User/LLM, Client: Client/LLM determines Tool 'name' and necessary 'arguments' based on user intent and tool 'inputSchema'.\n\n    opt User Confirmation Recommended\n        Client-&gt;&gt;User/LLM: Show intended tool call (name, args)\n        User/LLM--&gt;&gt;Client: Approve/Deny call\n    end\n\n    Client-&gt;&gt;+Server: 3. Request: tools/call\n    Note right of Client: Params include tool 'name' and 'arguments' object.\n\n    Server--&gt;&gt;-Client: 4. Response: tools/call (result or error)\n    Note left of Server: Server validates args, checks auth, executes tool.\n    Note left of Server: Result contains 'content' array and 'isError' boolean.\n    Note left of Server: Protocol errors (e.g., Unknown tool, Invalid args) use standard JSON-RPC error response.\n\n</code></pre> <p>Flow Description:</p> <ol> <li>Client -&gt; Server (<code>tools/list</code> Request): The client requests the list of tools offered by the server, potentially using pagination (<code>cursor</code>).</li> <li>Server -&gt; Client (<code>tools/list</code> Response): The server returns a list of <code>Tool</code> objects, including their <code>name</code>, <code>description</code>, and crucially, the <code>inputSchema</code> defining required arguments.</li> <li>(Client/LLM/User Interaction): The client, potentially interacting with an LLM or the user, identifies the appropriate tool <code>name</code> to achieve a goal and gathers the required <code>arguments</code> matching the <code>inputSchema</code>.</li> <li>(User Confirmation - Recommended): Before executing a potentially impactful action, the client SHOULD present the intended tool call (name and arguments) to the user for explicit confirmation.</li> <li>Client -&gt; Server (<code>tools/call</code> Request): If confirmed (or if confirmation is skipped), the client sends the request to invoke the tool, providing the <code>name</code> and validated <code>arguments</code>.</li> <li>Server -&gt; Client (<code>tools/call</code> Response): The server validates the <code>arguments</code> against the schema again, performs authorization checks, executes the tool's logic, and returns the result. The result includes an array of <code>content</code> items and an <code>isError</code> flag indicating success or failure of the tool's execution. Protocol-level errors (invalid tool name, bad arguments before execution) are returned as standard JSON-RPC errors.</li> </ol> <p>Security Implications: See Section 4.3 for detailed considerations: - This is a high-risk operation due to potential code execution. - Strict server-side input validation against <code>inputSchema</code> is paramount. - Authorization checks are essential before tool execution. - User confirmation (human-in-the-loop) is strongly recommended. - Clients must treat tool descriptions/annotations as untrusted. - Potential for data exfiltration via arguments. - Need for output sanitization by the server and careful handling by the client. - Rate limiting is critical to prevent DoS.</p>"},{"location":"05-communication-patterns/#54-prompt-discovery-usage","title":"5.4. Prompt Discovery &amp; Usage","text":"<p>This pattern covers how a client discovers predefined prompts (like slash commands) and retrieves their content, potentially customized with arguments.</p> <pre><code>sequenceDiagram\n    participant User\n    participant Client\n    participant Server\n\n    Note over Client,Server: Assumes successful initialization and 'prompts' capability negotiated.\n\n    Client-&gt;&gt;+Server: 1. Request: prompts/list\n    Note right of Client: Optionally includes 'cursor' for pagination.\n\n    Server--&gt;&gt;-Client: 2. Response: prompts/list (result)\n    Note left of Server: Contains a page of 'Prompt' objects (name, description, arguments definition) and potentially 'nextCursor'.\n\n    Note over User, Client: User selects a prompt (e.g., via UI like a slash command).\n    Note over User, Client: Client gathers necessary 'arguments' based on user input and prompt definition.\n\n    Client-&gt;&gt;+Server: 3. Request: prompts/get\n    Note right of Client: Params include prompt 'name' and collected 'arguments' object.\n\n    Server--&gt;&gt;-Client: 4. Response: prompts/get (result or error)\n    Note left of Server: Server validates args, checks auth, generates prompt content by injecting args into template.\n    Note left of Server: Result contains 'description' and 'messages' array (role, content).\n\n    Note over Client: Client uses the received 'messages' (e.g., displays to user, sends to LLM).\n\n</code></pre> <p>Flow Description:</p> <ol> <li>Client -&gt; Server (<code>prompts/list</code> Request): The client requests the list of available prompts, often to populate a UI element like a command palette or slash command menu.</li> <li>Server -&gt; Client (<code>prompts/list</code> Response): The server returns a list of <code>Prompt</code> objects, defining their <code>name</code>, <code>description</code>, and any <code>arguments</code> they accept.</li> <li>(User/Client Interaction): The user typically selects a prompt from the client's UI. The client then gathers values for any required arguments defined in the prompt definition.</li> <li>Client -&gt; Server (<code>prompts/get</code> Request): The client requests the actual content of the selected prompt, providing its <code>name</code> and the collected <code>arguments</code>.</li> <li>Server -&gt; Client (<code>prompts/get</code> Response): The server validates the arguments, checks authorization, and generates the final prompt content (an array of <code>messages</code>) potentially by inserting the provided arguments into a server-side template. It returns the resulting <code>messages</code>.</li> <li>(Client Action): The client uses the received <code>messages</code> array \u2013 for example, by displaying it to the user, prepopulating an input field, or using it as context for an LLM call.</li> </ol> <p>Security Implications: See Section 4.4 for detailed considerations: - Server-side sanitization of <code>arguments</code> before insertion into templates is crucial to prevent injection attacks. - Access control should apply to listing and getting prompts. - Potential for sensitive data exposure in prompt templates or generated messages. - Clients need to handle received message <code>content</code> (text, image, audio, resource) safely.</p>"},{"location":"05-communication-patterns/#55-server-initiated-sampling","title":"5.5. Server-Initiated Sampling","text":"<p>This pattern describes how a server can request the client to perform an LLM generation, enabling server-side agentic behavior while keeping LLM access control client-side.</p> <pre><code>sequenceDiagram\n    participant Server\n    participant Client\n    participant User\n    participant LLM\n\n    Note over Server,Client: Assumes successful initialization and 'sampling' capability negotiated by Client.\n\n    Server-&gt;&gt;Client: 1. Request: sampling/createMessage\n    Note left of Server: Params include 'messages', 'systemPrompt', 'modelPreferences', etc.\n\n    opt User Confirmation STRONGLY Recommended\n        Client-&gt;&gt;User: 2. Show request details\n        User--&gt;&gt;Client: 3. Approve / Modify / Deny\n    end\n\n    alt Request Approved by User\n        Client-&gt;&gt;LLM: 4. Send request to Client's LLM\n        Note right of Client: Uses approved prompt, selects model.\n\n        LLM--&gt;&gt;Client: 5. LLM Response\n\n        opt User Review of Response Recommended\n             Client-&gt;&gt;User: 6. Show generated response\n             User--&gt;&gt;Client: 7. Approve / Modify / Deny\n        end\n\n        Client--&gt;&gt;Server: 8. Response: sampling/createMessage (result)\n        Note right of Client: Contains generated 'content', 'role', 'model', etc.\n\n    else Request Denied by User\n        Client--&gt;&gt;Server: 9. Response: sampling/createMessage (error)\n        Note right of Client: Error indicating user rejection or failure.\n    end\n</code></pre> <p>Flow Description:</p> <ol> <li>Server -&gt; Client (<code>sampling/createMessage</code> Request): The server sends a request asking the client to generate text (or other content) using its LLM. The request includes the prompt context (<code>messages</code>), optional system prompt, and preferences for model selection (<code>modelPreferences</code>).</li> <li>(User Confirmation - Recommended): The client receives the request and SHOULD present it to the user for review and explicit approval. The user should be able to see the prompt content and potentially modify it or select/confirm the target LLM.</li> <li>(User Action): The user approves, potentially modifies, or denies the request via the client's UI.</li> <li>Client -&gt; LLM (Internal): If approved, the client formats the request (using the potentially modified prompt) and sends it to its configured LLM service, selecting a model based on the server's preferences and client-side availability/rules.</li> <li>LLM -&gt; Client (Internal): The LLM service processes the request and returns the generated content to the client.</li> <li>(User Review - Optional but Recommended): The client MAY present the LLM's response to the user for review before sending it back to the server.</li> <li>(User Action): The user approves, potentially modifies, or denies the response.</li> <li>Client -&gt; Server (<code>sampling/createMessage</code> Response - Result): If the process was approved (potentially after response review), the client sends a successful result back to the server, containing the generated <code>content</code>, the <code>role</code> (<code>assistant</code>), the actual <code>model</code> used, and the <code>stopReason</code>.</li> <li>Client -&gt; Server (<code>sampling/createMessage</code> Response - Error): If the user denied the request at step 3, or if any other error occurred (e.g., LLM API error, timeout), the client sends an error response back to the server.</li> </ol> <p>Security Implications: See Section 4.5 for detailed considerations: - User Control is Paramount: Failure to implement mandatory user confirmation steps (Steps 2-3) breaks the trust model and allows servers to potentially manipulate the client's LLM without oversight. - Prompt Injection: Server-provided <code>messages</code> can be used for prompt injection against the client's LLM. - Resource Consumption: Client needs rate limiting to prevent DoS via sampling requests. - Data Leakage: Sensitive data can flow from Server -&gt; Client (in prompt) and potentially Client -&gt; Server (in LLM response).</p>"},{"location":"05-communication-patterns/#56-resource-subscription-update-optional","title":"5.6. Resource Subscription &amp; Update (Optional)","text":"<p>This pattern applies if the server supports the <code>subscribe</code> capability for resources. It allows a client to be notified when a specific resource changes.</p> <pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant External Event\n\n    Note over Client,Server: Assumes successful initialization and 'resources: { subscribe: true }' capability negotiated.\n\n    Client-&gt;&gt;+Server: 1. Request: resources/subscribe\n    Note right of Client: Params include the 'uri' of the resource to watch.\n\n    Server--&gt;&gt;-Client: 2. Response: resources/subscribe (result or error)\n    Note left of Server: Confirms subscription or returns error (e.g., URI not found, subscription not allowed).\n\n    Note over Server, External Event: Time passes... Resource content changes externally.\n    External Event-&gt;&gt;Server: (Trigger update for watched resource)\n\n    Server--)Client: 3. Notification: notifications/resources/updated\n    Note left of Server: Params include the 'uri' of the changed resource.\n\n    Note over Client: Client knows the resource is potentially stale.\n\n    Client-&gt;&gt;+Server: 4. Request: resources/read\n    Note right of Client: Requests the updated content using the 'uri'.\n\n    Server--&gt;&gt;-Client: 5. Response: resources/read (result)\n    Note left of Server: Returns the new resource content.\n\n</code></pre> <p>Flow Description:</p> <ol> <li>Client -&gt; Server (<code>resources/subscribe</code> Request): The client requests to be notified of changes for a specific resource identified by its <code>uri</code>.</li> <li>Server -&gt; Client (<code>resources/subscribe</code> Response): The server acknowledges the subscription request, potentially performing checks to ensure the resource exists and the client is allowed to subscribe. It returns an empty success result or an error.</li> <li>(External Change &amp; Notification): At some later time, the underlying data represented by the subscribed resource <code>uri</code> changes due to external factors. The server detects this change.</li> <li>Server -&gt; Client (<code>notifications/resources/updated</code> Notification): The server sends a notification to the client, indicating that the resource specified by the <code>uri</code> has been updated.</li> <li>(Client Action - Fetch Update): Upon receiving the notification, the client knows its cached version (if any) might be stale. It typically sends a <code>resources/read</code> request to the server using the same <code>uri</code> to fetch the updated content.</li> <li>Server -&gt; Client (<code>resources/read</code> Response): The server responds with the current content of the resource, as detailed in Section 5.2.</li> </ol> <p> </p>"},{"location":"06-trust-boundaries/","title":"Trust Boundaries","text":""},{"location":"06-trust-boundaries/#6-trust-boundaries","title":"6. Trust Boundaries","text":"<p>A trust boundary is a point in the system where data or execution transitions from one trust level to another. Identifying these boundaries is crucial for determining where security controls (authentication, authorization, input validation, output encoding, etc.) are most needed. In the MCP ecosystem, several key boundaries exist:</p> <ul> <li>User &lt;-&gt; Host/Client UI: The interface where the user interacts with the MCP-enabled application. Trust depends on the Host application's security and UI/UX clarity.</li> <li>Host/Client &lt;-&gt; MCP Server: The core MCP communication channel (over transports like stdio, HTTP/S, WebSockets). This is a major boundary, often between different processes or machines, potentially involving untrusted servers.</li> <li>Host/Client &lt;-&gt; LLM Service: When using the <code>sampling</code> feature, the Host/Client communicates with an external LLM API. Trust relies on the LLM provider's security and the API contract.</li> <li>MCP Server &lt;-&gt; External Systems: MCP Servers often act as intermediaries, accessing databases, APIs, filesystems, or other resources based on MCP requests (especially for <code>resources/read</code> and <code>tools/call</code>).</li> <li>MCP Server Internal Boundaries: Within the server itself, boundaries exist between request handling logic, tool execution logic, resource access logic, and data stores.</li> </ul> <p>Understanding the assumptions and risks at each boundary is critical for designing secure MCP implementations.</p>"},{"location":"06-trust-boundaries/#61-user-hostclient-ui","title":"6.1. User &lt;-&gt; Host/Client UI","text":"<ul> <li>Description: The interface presented by the Host application (IDE, chat client) where the user interacts with MCP features, implicitly or explicitly.</li> <li>Trust Assumptions: The user generally trusts the Host application they are running, but may not fully trust all extensions or servers it connects to via MCP. The Host application is trusted to accurately represent information and actions related to MCP.</li> <li>Key Risks:<ul> <li>Misleading UI: The Host UI might not clearly indicate which server is providing a resource/tool/prompt, or what actions a tool/sampling request will perform, leading the user to approve unsafe operations.</li> <li>Lack of Consent/Control: The Host might not implement proper consent flows (as recommended by the MCP spec) for resource access, tool execution, or sampling, leading to unexpected data exposure or actions.</li> <li>UI Redressing/Clickjacking: Standard web/UI vulnerabilities in the Host application could be exploited to trick the user into unintended MCP-related actions.</li> <li>Host Compromise: If the Host application itself is compromised, all MCP interactions become untrustworthy.</li> </ul> </li> <li>Required Controls (Host Application Responsibility):<ul> <li>Clear Attribution: Clearly display the source (MCP Server) of resources, tools, and prompts.</li> <li>Explicit Consent: Implement robust, understandable confirmation dialogs for:<ul> <li>Connecting to new MCP Servers.</li> <li>Granting access to filesystem roots (<code>roots</code> feature).</li> <li>Authorizing OAuth flows (Section 3.3).</li> <li>Executing <code>tools/call</code> requests, showing the tool name and arguments.</li> <li>Approving <code>sampling/createMessage</code> requests, showing the prompt content.</li> </ul> </li> <li>Secure UI Development: Follow standard secure UI practices to prevent injection, clickjacking, etc.</li> <li>Input Sanitization: Sanitize any user input that might become part of MCP request parameters (e.g., arguments for <code>prompts/get</code>).</li> <li>Output Encoding/Sanitization: Safely render information received from MCP Servers (e.g., resource content, tool results, log messages) to prevent XSS if displayed in the UI.</li> </ul> </li> </ul>"},{"location":"06-trust-boundaries/#62-hostclient-mcp-server","title":"6.2. Host/Client &lt;-&gt; MCP Server","text":"<ul> <li>Description: The communication channel where JSON-RPC messages are exchanged between the client (running within the Host) and the MCP server. This occurs over a transport like stdio, HTTP/S, or WebSockets.</li> <li>Trust Assumptions: This is often the least trusted boundary, especially if connecting to third-party or public MCP servers. The client cannot inherently trust the server, and the server cannot inherently trust the client.</li> <li>Key Risks:<ul> <li>Untrusted Server: Malicious server attempts to exploit client vulnerabilities via crafted responses/notifications, requests unauthorized actions (e.g., sampling), provides malicious resource content/tool results, lies about capabilities, causes DoS.</li> <li>Untrusted Client: Malicious client attempts to exploit server vulnerabilities via crafted requests/notifications, accesses unauthorized resources/tools, bypasses auth, lies about capabilities, causes DoS (e.g., request flooding, large requests).</li> <li>Eavesdropping/Tampering (Transport): If the transport layer is not secured (e.g., plain HTTP/WS instead of HTTPS/WSS, unencrypted stdio), messages can be intercepted or modified in transit.</li> <li>Authentication/Authorization Bypass: Weak or missing authentication/authorization mechanisms allow unauthorized access.</li> <li>Input Validation Failures: Failure on either side to validate incoming message parameters (<code>params</code>) can lead to various injection attacks or crashes.</li> <li>Information Leakage: Sensitive data might be leaked via error messages, log messages, resource/tool/prompt metadata, or even timing side channels.</li> </ul> </li> <li>Required Controls:<ul> <li>Transport Security: Mandate secure transports (HTTPS, WSS) for non-local connections. Protect stdio communication if applicable (e.g., ensure only intended processes can connect).</li> <li>Authentication: Implement strong authentication for both client and server where necessary (e.g., OAuth 2.1 for HTTP as per spec (Section 3.3), environment/token auth for stdio).</li> <li>Authorization: Enforce granular authorization checks on the server before performing actions (listing/reading resources, calling tools, getting prompts). Use OAuth scopes or equivalent mechanisms.</li> <li>Rigorous Input Validation (Both Sides): Both client and server MUST validate all incoming request/notification parameters against the expected schema/types/constraints before processing. This includes URIs, tool arguments, prompt arguments, log levels, progress tokens, etc.</li> <li>Output Encoding/Sanitization (Both Sides): Data sent across the boundary (e.g., resource content, tool results, prompt messages, error details, log data) should be appropriately sanitized or encoded to prevent interpretation issues (like XSS) on the receiving end.</li> <li>Capability Enforcement: Both sides MUST check received requests/notifications against the capabilities negotiated during initialization.</li> <li>State Management: Securely manage session state, request IDs, subscription tokens, progress tokens to prevent reuse or hijacking.</li> <li>Rate Limiting/DoS Protection: Both sides should implement rate limiting on incoming requests/notifications.</li> <li>Least Privilege: Design both client and server components to operate with the minimum necessary privileges.</li> </ul> </li> </ul>"},{"location":"06-trust-boundaries/#63-hostclient-llm-service","title":"6.3. Host/Client &lt;-&gt; LLM Service","text":"<ul> <li>Description: The interface between the Host/Client application and the external Large Language Model service provider API (e.g., OpenAI, Anthropic, Google AI). This is primarily relevant for the <code>sampling</code> feature but also if the client uses LLMs for interpreting user requests before forming MCP calls.</li> <li>Trust Assumptions: The Host/Client generally trusts the LLM provider to adhere to its API contract, privacy policy, and security practices. However, the specific model's behavior might be unpredictable (hallucinations, potential for harmful content generation).</li> <li>Key Risks:<ul> <li>Data Privacy/Confidentiality: Sensitive data sent within prompts (originating from the user, the Host application, or even the MCP Server via <code>sampling/createMessage</code>) is exposed to the LLM provider. Risks include inadequate data handling by the provider, breaches, or use for model training contrary to policy/user consent.</li> <li>Prompt Injection: Malicious input (potentially originating from an untrusted MCP Server via <code>sampling/createMessage</code>) could manipulate the LLM into unintended actions, revealing sensitive information from its context, or generating harmful content.</li> <li>Insecure API Key Handling: Client needs to securely store and use API keys/credentials for the LLM service.</li> <li>Harmful Content Generation: The LLM might generate biased, inaccurate, offensive, or otherwise harmful content, which the client then needs to handle appropriately (filter, warn user, potentially block from being sent back to MCP Server).</li> <li>Cost Overruns: Uncontrolled or excessive API calls (potentially triggered by a malicious MCP server via <code>sampling</code>) could lead to high costs.</li> </ul> </li> <li>Required Controls (Host/Client Responsibility):<ul> <li>Secure Credential Management: Protect LLM API keys using secure storage (e.g., OS keychain, secrets management systems).</li> <li>Data Minimization: Send only necessary data to the LLM API. Consider filtering or anonymizing sensitive information before inclusion in prompts if possible.</li> <li>Clear User Consent/Policy: Inform users about which LLM provider is used and how their data is handled (referencing provider policies).</li> <li>Input Sanitization/Validation: Sanitize/validate data before including it in prompts sent to the LLM, especially if it originates from untrusted sources like an MCP server.</li> <li>Output Filtering/Moderation: Implement mechanisms to detect and handle harmful or inappropriate content generated by the LLM before displaying it or sending it back to an MCP server.</li> <li>Rate Limiting/Cost Controls: Implement client-side controls to limit the frequency and potential cost of LLM API calls, especially those triggered via <code>sampling</code>.</li> <li>Context Separation: Be careful about the context provided to the LLM; avoid including sensitive internal application state or unrelated user data unless explicitly necessary and consented to.</li> </ul> </li> </ul>"},{"location":"06-trust-boundaries/#64-mcp-server-external-systems","title":"6.4. MCP Server &lt;-&gt; External Systems","text":"<ul> <li>Description: The interface between the MCP Server and any external systems it interacts with to provide resources or execute tools. This includes databases, external APIs, local filesystems, version control systems, etc.</li> <li>Trust Assumptions: Highly variable. The Server might fully trust its own database but treat external third-party APIs with caution. Trust in the local filesystem depends on the server's deployment environment and permissions.</li> <li>Key Risks:<ul> <li>Credential Management: Server needs to securely store and use credentials (API keys, DB passwords, service account keys) for external systems.</li> <li>Injection Attacks: User/Client-controlled input from MCP requests (e.g., resource URIs, tool arguments) might be insecurely used in queries or commands sent to external systems (SQL injection, command injection, SSRF if accessing URLs).</li> <li>Data Exposure: Server might inadvertently expose sensitive data from external systems via MCP resource content, tool results, prompt messages, or log messages.</li> <li>External System Compromise: A compromised external system could return malicious data to the server, which might then be relayed to the MCP client.</li> <li>Denial of Service: Server might overload external systems with requests, potentially triggered by excessive MCP client requests.</li> <li>Excessive Permissions: The server process might have overly broad permissions on the filesystem or other external resources it accesses.</li> </ul> </li> <li>Required Controls (MCP Server Responsibility):<ul> <li>Secure Credential Management: Store external system credentials securely (secrets management, environment variables, secure configuration).</li> <li>Input Validation and Parameterization: Rigorously validate and sanitize any input originating from MCP requests before using it to interact with external systems. Use parameterized queries (for SQL), safe file path handling, and proper escaping for shell commands or API calls.</li> <li>Output Sanitization/Filtering: Filter or sanitize data retrieved from external systems before including it in MCP responses or logs.</li> <li>Least Privilege: Run the server process with the minimum necessary permissions to access required external systems/files.</li> <li>Network Segmentation/Firewalls: Restrict the server's outbound network access to only necessary external systems.</li> <li>Error Handling: Handle errors from external systems gracefully without leaking sensitive details.</li> <li>Rate Limiting: Implement rate limiting for requests to external systems, potentially tied to MCP client rate limits.</li> <li>Validate External System Responses: Treat data from external systems (especially third-party APIs) as potentially untrusted; validate or sanitize it before use.</li> </ul> </li> </ul>"},{"location":"06-trust-boundaries/#65-mcp-server-internal-boundaries","title":"6.5. MCP Server Internal Boundaries","text":"<ul> <li>Description: Interfaces between different logical components within the MCP server process itself (e.g., between the main request handler, authorization logic, resource provider modules, tool execution sandbox, data access layers).</li> <li>Trust Assumptions: While often within the same process, different components might operate with different privileges or handle data of varying sensitivity. Trust should not be implicitly assumed between components.</li> <li>Key Risks:<ul> <li>Privilege Escalation: A vulnerability in a lower-privileged component (e.g., request parsing) could potentially allow an attacker to influence or control higher-privileged components (e.g., tool execution, direct filesystem access).</li> <li>Data Flow Violations: Sensitive data (e.g., credentials for external systems, user data from resources) might incorrectly flow between components and get logged or returned inappropriately.</li> <li>Bypassed Controls: Authorization or validation logic might be incorrectly bypassed if components call each other directly without going through the proper checks.</li> <li>Insecure State Management: Shared state between components might be manipulated in unexpected ways.</li> </ul> </li> <li>Required Controls (MCP Server Responsibility):<ul> <li>Modular Design: Structure the server code into well-defined modules with clear responsibilities and interfaces.</li> <li>Centralized Input Validation: Perform initial validation of MCP request parameters at the entry point before passing data to internal components.</li> <li>Centralized Authorization: Enforce authorization checks consistently before dispatching requests to resource/tool/prompt handling logic.</li> <li>Data Flow Analysis: Carefully track how sensitive data flows between components, ensuring it's only accessed where necessary and not leaked (e.g., into logs or generic error messages).</li> <li>Sandboxing (for Tools): If possible and applicable, execute high-risk tool logic in a sandboxed environment with restricted permissions (e.g., separate process, container, specific language-level sandboxing).</li> <li>Defensive Programming: Components should validate assumptions about data received from other internal components, especially if trust levels differ.</li> <li>Secure State Handling: Protect shared state using appropriate synchronization mechanisms and validate state transitions. </li> </ul> </li> </ul>"},{"location":"07-security-considerations-per-component/","title":"Security Considerations","text":""},{"location":"07-security-considerations-per-component/#7-security-considerations-per-component","title":"7. Security Considerations per Component","text":"<p>This section consolidates the key security risks and required controls organized by the major MCP components and features.</p>"},{"location":"07-security-considerations-per-component/#71-initialization-lifecycle-initialize-notificationsinitialized","title":"7.1. Initialization &amp; Lifecycle (<code>initialize</code>, <code>notifications/initialized</code>)","text":"<ul> <li>Key Risks: Capability spoofing/misrepresentation, protocol version downgrade attacks, information leakage (<code>clientInfo</code>/<code>serverInfo</code>), resource exhaustion during init, state mismatches if <code>initialized</code> notification fails.</li> <li>Required Controls: Strict validation of negotiated capabilities against actual implementation, secure version negotiation logic, minimize info in <code>clientInfo</code>/<code>serverInfo</code>, rate limit <code>initialize</code> requests, robust state management, enforce request order around <code>initialize</code>/<code>initialized</code>.</li> <li>(See Section 3.2, Section 4.1, Section 6.2)</li> </ul>"},{"location":"07-security-considerations-per-component/#72-resources-resourceslist-resourcesread-resourcestemplateslist-resourcessubscribe-notifications","title":"7.2. Resources (<code>resources/list</code>, <code>resources/read</code>, <code>resources/templates/list</code>, <code>resources/subscribe</code>, notifications)","text":"<ul> <li>Key Risks: Path traversal via URI manipulation (<code>resources/read</code>, <code>resources/subscribe</code>), insufficient access control (listing or reading sensitive data), data leakage via metadata in <code>resources/list</code>, DoS via large resource requests or subscription storms, insecure client-side handling of received content (<code>text</code>/<code>blob</code>), URI template injection, MIME type spoofing.</li> <li>Required Controls (Server): Rigorous URI validation/canonicalization, enforce authorization before list/read/subscribe, filter lists based on permissions, implement size limits/streaming for <code>resources/read</code>, rate limit subscriptions and notifications.</li> <li>Required Controls (Client): Safely handle/render received content based on MIME type, treat cursors as opaque.</li> <li>(See Section 4.2, Section 5.2, Section 5.6, Section 6.2, Section 6.4, Section 6.5)</li> </ul>"},{"location":"07-security-considerations-per-component/#73-tools-toolslist-toolscall-notifications","title":"7.3. Tools (<code>tools/list</code>, <code>tools/call</code>, notifications)","text":"<ul> <li>Key Risks: Arbitrary code execution (highest risk), injection attacks via tool <code>arguments</code>, insufficient access control, data exfiltration via arguments, output sanitization failures (leading to XSS on client), untrusted tool descriptions/annotations misleading user/LLM, DoS via excessive calls.</li> <li>Required Controls (Server): Rigorous input validation against <code>inputSchema</code>, strong authorization checks, sanitize output <code>content</code>, rate limit <code>tools/call</code>, consider sandboxing tool execution.</li> <li>Required Controls (Client): Implement mandatory user confirmation (human-in-the-loop) showing tool name and arguments, treat descriptions/annotations as untrusted, handle received <code>content</code> safely.</li> <li>(See Section 4.3, Section 5.3, Section 6.1, Section 6.2, Section 6.4, Section 6.5)</li> </ul>"},{"location":"07-security-considerations-per-component/#74-prompts-promptslist-promptsget-notifications","title":"7.4. Prompts (<code>prompts/list</code>, <code>prompts/get</code>, notifications)","text":"<ul> <li>Key Risks: Server-side argument injection into templates, insufficient access control (listing/getting prompts), sensitive data exposure in templates or generated messages, misleading prompts tricking user/LLM, unsafe handling of embedded resources.</li> <li>Required Controls (Server): Sanitize arguments before template insertion, enforce authorization, design templates carefully to avoid data exposure.</li> <li>Required Controls (Client): Handle received message <code>content</code> (including embedded resources) safely.</li> <li>(See Section 4.4, Section 5.4, Section 6.2)</li> </ul>"},{"location":"07-security-considerations-per-component/#75-sampling-samplingcreatemessage","title":"7.5. Sampling (<code>sampling/createMessage</code>)","text":"<ul> <li>Key Risks: Bypass of client-side user consent, prompt injection from server manipulating client's LLM, client resource exhaustion (cost/rate limiting), sensitive data leakage (Server-&gt;Client in prompt, potentially Client-&gt;Server in response), harmful content generation by LLM.</li> <li>Required Controls (Client): Implement mandatory user confirmation (view/edit prompt), sanitize/validate server-provided prompt content before sending to LLM, implement rate limiting/cost controls, filter/moderate LLM responses before returning to server or user.</li> <li>(See Section 4.5, Section 5.5, Section 6.1, Section 6.2, Section 6.3)</li> </ul>"},{"location":"07-security-considerations-per-component/#76-roots-rootslist-notifications","title":"7.6. Roots (<code>roots/list</code>, notifications)","text":"<ul> <li>Key Risks: Information disclosure (filesystem structure), exposure of unintended/sensitive directories by client.</li> <li>Required Controls (Client): Expose only intended roots, ideally with user consent per root, validate exposed URIs.</li> <li>Required Controls (Server): Respect root boundaries when forming resource URIs (though enforcement relies on resource access controls).</li> <li>(See Section 4.6, Section 6.1, Section 6.2)</li> </ul>"},{"location":"07-security-considerations-per-component/#77-authorization-http-oauth-21","title":"7.7. Authorization (HTTP - OAuth 2.1)","text":"<ul> <li>Key Risks: Insecure transport (HTTP instead of HTTPS), weak PKCE implementation, improper redirect URI validation (Open Redirect), insecure client-side token storage, weak server-side token validation (expiry, scope, signature), insecure dynamic client registration, third-party auth complexities.</li> <li>Required Controls: Enforce HTTPS, use robust PKCE libraries, perform strict redirect URI matching, use secure storage for tokens (client), implement thorough token validation (server), secure registration endpoints, carefully implement third-party auth flows.</li> <li>(See Section 3.3, Section 6.2)</li> </ul>"},{"location":"07-security-considerations-per-component/#78-utilities-logging-pagination-cancellation-progress-ping-completion","title":"7.8. Utilities (Logging, Pagination, Cancellation, Progress, Ping, Completion)","text":"<ul> <li>Key Risks: Sensitive data leakage in logs (<code>notifications/message</code>), DoS via log/notification flooding (logs, progress, cancellation), insecure pagination cursor handling, information leakage via completion suggestions.</li> <li>Required Controls: Sanitize all log data (Server), rate limit logs/notifications (Server/Client), validate cursors (Server), treat cursors as opaque (Client), authorize and filter completion requests/responses (Server).</li> <li>(See Section 4.7) </li> </ul>"},{"location":"08-stride-modeling/","title":"Threat Modeling (STRIDE)","text":""},{"location":"08-stride-modeling/#8-threat-modeling-stride","title":"8. Threat Modeling (STRIDE)","text":"<p>Applying the STRIDE threat modeling framework (Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege) helps categorize the potential security risks within the MCP ecosystem identified in the preceding sections.</p>"},{"location":"08-stride-modeling/#81-spoofing","title":"8.1. Spoofing","text":"<p>Threats related to illegitimate impersonation:</p> <ul> <li>Client/Server Impersonation: Malicious entities could impersonate legitimate Clients or Servers if authentication is weak or absent (Section 3.3, Section 6.2). This is especially relevant over insecure transports or with inadequate credential handling (e.g., stdio environment variables - Section 3.3).</li> <li>Capability Spoofing: During initialization, a Client or Server might falsely claim capabilities it doesn't securely support or intend to honor (Sections 3.2, 4.1, 7.1).</li> <li>MIME Type Spoofing: A malicious Server could provide a misleading <code>mimeType</code> for resource content to trick the Client into unsafe handling (Section 4.2).</li> <li>Misleading UI (Host): The Host UI could fail to accurately attribute actions/data to the correct Server, effectively spoofing the origin from the user's perspective (Section 6.1).</li> <li>Misleading Descriptions/Annotations: Servers could provide false tool descriptions or annotations to trick users/LLMs into invoking harmful tools (Sections 4.3, 7.3).</li> </ul>"},{"location":"08-stride-modeling/#82-tampering","title":"8.2. Tampering","text":"<p>Threats related to unauthorized modification of data or code:</p> <ul> <li>Message Tampering (Transport): Modification of MCP messages in transit if the transport layer is not secure (e.g., plain HTTP/WS, unprotected stdio) (Section 6.2).</li> <li>Resource Content Tampering: If a Server's access controls are bypassed or flawed, malicious Clients could potentially modify resources (though MCP core focuses on read; write often implemented via Tools).</li> <li>Tool Argument Tampering: Malicious Clients could provide malformed or unexpected arguments to <code>tools/call</code> to induce unintended behavior if server-side validation is weak (Sections 4.3, 7.3, 9.2, 9.4).</li> <li>Prompt Argument Tampering: Malicious Clients providing crafted arguments to <code>prompts/get</code> could potentially exploit argument injection vulnerabilities on the Server (Section 4.4).</li> <li>Sampling Prompt Tampering: Malicious Servers providing crafted <code>messages</code> or <code>systemPrompt</code> to <code>sampling/createMessage</code> could manipulate the Client's LLM behavior (Sections 4.5, 7.5).</li> <li>State Management Tampering: Manipulation of session state, request IDs, progress tokens, or pagination cursors if not handled securely (Sections 3.1, 4.7, 6.2).</li> </ul>"},{"location":"08-stride-modeling/#83-repudiation","title":"8.3. Repudiation","text":"<p>Threats related to denying actions performed:</p> <ul> <li>Lack of Auditing: Insufficient logging on Client or Server side makes it difficult to prove whether a specific tool call, resource access, or sampling request occurred or who initiated it (Implicit, related to Logging in Section 7.8, needs explicit Logging/Monitoring section).</li> <li>Client Action Repudiation: A Client could potentially deny initiating a harmful tool call if logging is inadequate and user consent wasn't properly recorded.</li> <li>Server Action Repudiation: A Server could deny having sent a malicious sampling request or faulty resource data if logging is insufficient.</li> </ul> <p>Note: Robust logging and clear user consent records are the primary mitigations. </p>"},{"location":"08-stride-modeling/#84-information-disclosure","title":"8.4. Information Disclosure","text":"<p>Threats related to exposure of sensitive information:</p> <ul> <li>Eavesdropping (Transport): Interception of MCP messages containing sensitive data (arguments, resource content, tokens) over insecure transports (Section 6.2).</li> <li>Information Leakage (<code>clientInfo</code>/<code>serverInfo</code>): Exposing potentially sensitive software versions during initialization (Sections 3.2, 7.1).</li> <li>Error Message Leakage: Leaking internal system details or sensitive data in JSON-RPC <code>error</code> objects (<code>message</code> or <code>data</code> fields) (Sections 3.1, 4.3, 6.4).</li> <li>Log Data Leakage: Sensitive data (credentials, PII, request details) being included in logs sent via <code>notifications/message</code> or logged locally (Sections 4.7, 7.8, 10).</li> <li>Resource Listing Leakage: <code>resources/list</code> potentially revealing existence or metadata of sensitive resources even if content access is restricted (Section 4.2).</li> <li>Resource Content Exposure: Unauthorized access to sensitive resource content via <code>resources/read</code> due to weak access controls or path traversal vulnerabilities (Sections 4.2, 7.2).</li> <li>Tool Output Leakage: Tools returning sensitive data from external systems or internal state in their <code>content</code> result (Section 4.3).</li> <li>Prompt Content Exposure: Sensitive information embedded in prompt templates or generated via <code>prompts/get</code> (Section 4.4).</li> <li>Sampling Prompt/Response Leakage: Sensitive data flowing from Server-&gt;Client in <code>sampling/createMessage</code> prompts or Client-&gt;Server in responses (Sections 4.5, 7.5).</li> <li>Root Information Disclosure: Client exposing sensitive filesystem structure information via <code>roots/list</code> (Sections 4.6, 7.6).</li> <li>Token Leakage: Improper handling/storage of OAuth tokens (Client) or insecure <code>redirect_uri</code> validation (Server) leading to token exposure (Section 3.3).</li> <li>Completion Suggestion Leakage: <code>completion/complete</code> suggesting sensitive filenames, user data, etc. (Section 4.7).</li> </ul>"},{"location":"08-stride-modeling/#85-denial-of-service-dos","title":"8.5. Denial of Service (DoS)","text":"<p>Threats related to preventing legitimate use:</p> <ul> <li>Request Flooding: Overwhelming Client or Server with excessive requests (<code>initialize</code>, <code>resources/list</code>, <code>tools/call</code>, <code>ping</code>, etc.) or notifications (<code>notifications/cancelled</code>, <code>notifications/progress</code>, <code>notifications/message</code>) (Sections 3.1, 3.2, 4.2, 4.3, 4.5, 4.7).</li> <li>Large Request Payloads: Sending large capability objects during init, large resource requests (<code>resources/read</code>), large tool arguments (<code>tools/call</code>), or large base64 blobs (<code>blob</code> in resource content/tool results) causing resource exhaustion (memory, CPU) (Sections 3.2, 4.2, 4.3, 4.5).</li> <li>Subscription Storms: Client subscribing to numerous or frequently changing resources, overwhelming the Server with update checks and notifications (<code>notifications/resources/updated</code>) (Section 4.2).</li> <li>Cost Overruns (Client): Malicious Server triggering excessive, expensive LLM calls via <code>sampling/createMessage</code> (Sections 4.5, 6.3, 7.5).</li> <li>Resource Locking/Exhaustion (Server): Tools consuming excessive resources (CPU, memory, network, file handles) or causing deadlocks, potentially triggered by malicious arguments (Section 4.3). Improper shutdown leaving orphaned processes (Section 3.2).</li> <li>External System DoS: Server overloading downstream external systems based on excessive Client requests (Section 6.4).</li> <li>Batching Abuse: Sending extremely large batches of requests/notifications (Section 3.1).</li> </ul>"},{"location":"08-stride-modeling/#86-elevation-of-privilege-eop","title":"8.6. Elevation of Privilege (EoP)","text":"<p>Threats related to gaining unauthorized capabilities or permissions:</p> <ul> <li>Bypassing Authorization: Exploiting flaws in server-side access control logic to access unauthorized resources (<code>resources/read</code>), tools (<code>tools/call</code>), or prompts (<code>prompts/get</code>) (Sections 3.3, 4.2, 4.3, 4.4, 6.2).</li> <li>Path Traversal: Accessing files outside of permitted directories via crafted URIs in <code>resources/read</code> (Sections 4.2, 7.2, 9.1, 9.3).</li> <li>Tool-Based EoP: Exploiting vulnerabilities (e.g., command injection via arguments) within a tool's implementation to execute commands or access data with the Server's privileges (Sections 4.3, 7.3, 6.4).</li> <li>Bypassing Client Consent: Client/Host failing to implement mandatory user confirmation for <code>tools/call</code> or <code>sampling/createMessage</code>, effectively allowing the Server to perform actions the user didn't approve (Sections 2.6, 6.1, 7.3, 7.5).</li> <li>OAuth Scope Escalation: Exploiting flaws in OAuth scope definition or enforcement to gain broader access than authorized by the user (Section 3.3).</li> <li>Insecure Dynamic Client Registration: Malicious client registering itself with elevated privileges if the registration endpoint is insecure (Section 3.3).</li> <li>Server Internal Boundary EoP: Vulnerabilities allowing compromise of one server component to affect higher-privileged ones (Section 6.5). </li> </ul>"},{"location":"09-implementation-insights/","title":"Implementation Insights","text":""},{"location":"09-implementation-insights/#9-implementation-insights-from-reference-repos","title":"9. Implementation Insights (from Reference Repos)","text":"<p>This section documents observations about how the reference implementations (from the <code>modelcontextprotocol/servers</code> repository, covering the Python SDK and TypeScript examples) handle specific security-relevant aspects of the MCP protocol. Note: This is based on limited code review and may not be exhaustive.</p>"},{"location":"09-implementation-insights/#91-python-sdk-fileresource-path-validation-resourcesread","title":"9.1. Python SDK: <code>FileResource</code> Path Validation (<code>resources/read</code>)","text":"<ul> <li>Concern: Preventing Path Traversal when handling <code>file://</code> URIs in <code>resources/read</code> requests.</li> <li>Implementation (Python SDK within <code>modelcontextprotocol/servers</code>, specifically <code>src/mcp/server/fastmcp/resources/types.py</code>):<ul> <li>The <code>FileResource</code> class uses a <code>path: Path</code> attribute to represent the file location.</li> <li>A Pydantic validator (<code>validate_absolute_path</code>) ensures that the <code>path</code> provided when creating a <code>FileResource</code> object is absolute (<code>path.is_absolute()</code>).</li> <li>The <code>FileResource.read</code> method directly uses this validated <code>self.path</code> object to read the file (<code>self.path.read_text</code>/<code>read_bytes</code>).</li> </ul> </li> <li>Analysis:<ul> <li>Good: Ensures that paths used internally by <code>FileResource</code> are absolute, preventing relative path ambiguity at that stage.</li> <li>Potential Gap: The validation occurs when the <code>FileResource</code> object is created. The security relies heavily on how the incoming URI string from the client's <code>resources/read</code> request is parsed and converted into this <code>Path</code> object before <code>FileResource</code> is instantiated. The <code>validate_absolute_path</code> check alone does not prevent path traversal attacks like <code>file:///c:/allowed_dir/../forbidden_dir/secret.txt</code>. Such an input could resolve to an absolute path (<code>c:\\forbidden_dir\\secret.txt</code>) that passes the <code>is_absolute()</code> check but accesses an unauthorized location.</li> <li>Needed: A crucial validation step appears missing within the reviewed <code>FileResource</code> code: checking if the resolved absolute path is confined within a pre-defined, allowed base directory or set of roots. This check might exist elsewhere (e.g., in the <code>ResourceManager</code> that likely maps URIs to <code>Resource</code> objects, or in the main request handler), but it's not evident in the <code>FileResource</code> itself.</li> <li>Update (ResourceManager): Reviewing <code>ResourceManager.get_resource</code> shows it retrieves resources either from a dictionary of pre-registered concrete resources (<code>self._resources</code>) or by creating them dynamically via <code>ResourceTemplate</code> objects (<code>self._templates</code>). The <code>get_resource</code> method itself does not perform path canonicalization or boundary checks on the input URI string before lookup or template matching/creation. This means the security relies entirely on:<ol> <li>How concrete <code>FileResource</code> objects are initially registered (i.e., ensuring the <code>path</code> used during <code>add_resource</code> is safe and within bounds).</li> <li>How <code>ResourceTemplate</code> implementations (specifically <code>template.create_resource</code> and the underlying functions they wrap) handle URI parsing, path resolution, and boundary checks before creating the final <code>FileResource</code>.</li> </ol> </li> </ul> </li> <li>Conclusion: While the SDK ensures paths are absolute within a <code>FileResource</code> object, relying solely on this seems insufficient to prevent path traversal. The <code>ResourceManager</code> does not add further checks. The vulnerability window exists in how URIs are mapped to <code>FileResource</code> instances, either during initial registration or dynamic template creation. Effective path traversal prevention requires explicit boundary checks (e.g., comparing the resolved path against allowed root directories) during the URI-to-Resource mapping process.</li> </ul>"},{"location":"09-implementation-insights/#92-python-sdk-tool-argument-validation-toolscall","title":"9.2. Python SDK: Tool Argument Validation (<code>tools/call</code>)","text":"<ul> <li>Concern: Ensuring arguments provided in <code>tools/call</code> requests are validated against the tool's defined <code>inputSchema</code> before execution.</li> <li>Implementation (Python SDK within <code>modelcontextprotocol/servers</code>, specifically <code>src/mcp/server/fastmcp/tools/base.py</code> and <code>utilities/func_metadata.py</code>):<ul> <li>The <code>fastmcp</code> layer uses decorators (<code>@server.tool(...)</code>) to register Python functions as MCP tools.</li> <li>During registration, the <code>func_metadata</code> utility inspects the function's signature (parameter names and type hints) and dynamically creates a Pydantic <code>BaseModel</code> (<code>arg_model</code>) representing the expected arguments.</li> <li>The <code>inputSchema</code> returned in <code>tools/list</code> is generated from this Pydantic model (<code>arg_model.model_json_schema()</code>).</li> <li>When a <code>tools/call</code> request is received, the <code>Tool.run</code> method calls <code>FuncMetadata.call_fn_with_arg_validation</code>.</li> <li>This method first attempts to pre-parse any arguments that might be JSON strings (<code>pre_parse_json</code>).</li> <li>Crucially, it then calls <code>self.arg_model.model_validate(arguments_pre_parsed)</code>. This uses Pydantic to validate the (potentially pre-parsed) input arguments against the types and constraints defined by the function's type hints.</li> <li>If <code>model_validate</code> succeeds, the actual tool function is called with the validated and correctly typed arguments.</li> </ul> </li> <li>Analysis:<ul> <li>Good: Leverages a mature library (Pydantic) for robust validation based on Python type hints. This automatically handles type checking, required/optional fields, and potentially more complex validation rules defined via Pydantic's features (like <code>Field</code>).</li> <li>Good: The <code>pre_parse_json</code> step adds resilience against clients that might incorrectly serialize nested arguments as JSON strings.</li> <li>Implicit: The security relies on the developer accurately defining the tool function's signature with correct type hints. Missing or incorrect type hints could weaken the validation.</li> </ul> </li> <li>Conclusion: The Python SDK's <code>fastmcp</code> layer implements strong, type-hint-based validation for tool arguments using Pydantic. This significantly mitigates risks associated with malformed or type-incorrect arguments, a common source of vulnerabilities. Developers using this SDK must ensure their tool functions have accurate type annotations.</li> </ul>"},{"location":"09-implementation-insights/#93-typescript-server-example-filesystem-path-validation-for-file-tools","title":"9.3. TypeScript Server Example (<code>filesystem</code>): Path Validation for File Tools","text":"<ul> <li>Concern: Preventing Path Traversal when handling file paths provided by clients (contrast with Section 9.1).</li> <li>Implementation (TypeScript example within <code>modelcontextprotocol/servers</code>, specifically <code>src/filesystem/index.ts</code>):<ul> <li>This example server implements file operations (<code>read_file</code>, <code>write_file</code>, etc.) as MCP Tools, not via the <code>resources</code> feature.</li> <li>It uses <code>zod</code> for schema validation of tool arguments (e.g., <code>ReadFileArgsSchema.safeParse</code>).</li> <li>Crucially, after schema validation, it calls a dedicated <code>validatePath</code> async function before performing any filesystem operations (<code>fs.readFile</code>, <code>fs.writeFile</code>, etc.).</li> <li>The <code>validatePath</code> function performs several key steps:<ol> <li>Expands home directory tokens (<code>~</code>).</li> <li>Resolves the input path to an absolute path (<code>path.resolve</code>).</li> <li>Normalizes the absolute path (presumably handling <code>.</code> and <code>..</code>).</li> <li>Checks if the normalized path starts with any of the <code>allowedDirectories</code> configured at server startup.</li> <li>Uses <code>fs.realpath</code> to resolve symbolic links and checks if the real path also starts with an allowed directory.</li> <li>For potential write operations, it also checks if the parent directory is allowed.</li> </ol> </li> </ul> </li> <li>Analysis:<ul> <li>Good: Implements explicit, multi-step path validation after receiving the request and before accessing the filesystem.</li> <li>Good: Includes checks for allowed base directories, normalization, and symlink resolution, addressing common path traversal bypass techniques.</li> <li>Contrast with Python SDK <code>FileResource</code> (Section 9.1): This <code>validatePath</code> approach provides the necessary boundary checks that seemed potentially missing in the direct <code>FileResource</code> implementation within the Python SDK. It centralizes the path validation logic before filesystem access.</li> </ul> </li> <li>Conclusion: The <code>filesystem</code> TypeScript example demonstrates a robust pattern for handling client-provided file paths in MCP tools. It correctly identifies the need for explicit validation beyond basic schema checks, including normalization, base directory confinement, and symlink handling. This pattern should be adopted when implementing file access via MCP, whether through tools or the <code>resources</code> feature.</li> </ul>"},{"location":"09-implementation-insights/#94-typescript-server-examples-tool-argument-validation-toolscall","title":"9.4. TypeScript Server Examples: Tool Argument Validation (<code>tools/call</code>)","text":"<ul> <li>Concern: Ensuring arguments provided in <code>tools/call</code> requests are validated against the tool's defined <code>inputSchema</code> before execution (comparison to Section 9.2).</li> <li>Implementation (TypeScript examples within <code>modelcontextprotocol/servers</code>, e.g., <code>redis</code>, <code>github</code>, <code>filesystem</code> in <code>src/</code>):<ul> <li>Unlike the Python SDK's <code>fastmcp</code> layer which automatically validates arguments using Pydantic based on type hints, the reference TypeScript examples generally handle validation manually within the <code>server.setRequestHandler(CallToolRequestSchema, ...)</code> block.</li> <li>The common pattern observed is to use a dedicated schema validation library, typically <code>zod</code>.</li> <li>Inside the handler for a specific tool (e.g., within a <code>switch (name)</code> block), the code explicitly calls <code>.parse()</code> or <code>.safeParse()</code> on a corresponding <code>zod</code> schema (e.g., <code>RedisSetArgumentsSchema.parse(args)</code>, <code>GithubCreateIssueSchema.parse(args)</code>).</li> <li>This parsing/validation step happens before the arguments are used to perform the tool's action.</li> </ul> </li> <li>Analysis:<ul> <li>Good: Explicit validation is performed before using potentially untrusted client input.</li> <li>Good: Leverages a standard library (<code>zod</code>) for defining and enforcing schemas.</li> <li>Manual Effort: Requires developers to manually define a <code>zod</code> schema (or equivalent) that ideally matches the <code>inputSchema</code> advertised in <code>tools/list</code>, and to explicitly call the validation logic in each tool handler. There's a risk of mismatch between the advertised <code>inputSchema</code> and the actual validation performed if not kept in sync.</li> <li>Contrast with Python SDK (Section 9.2): The Python SDK's approach is more automatic, deriving validation from type hints, potentially reducing boilerplate and the risk of schema mismatches. The TypeScript examples require more explicit developer action for validation.</li> </ul> </li> <li>Conclusion: The reference TypeScript servers demonstrate a pattern of explicit, library-based (Zod) input validation within tool handlers. While effective, it places the responsibility on the developer to implement and maintain this validation for each tool, unlike the more integrated approach seen in the Python SDK's <code>fastmcp</code> layer. </li> </ul>"},{"location":"10-summary-hotspots/","title":"Summary","text":""},{"location":"10-summary-hotspots/#10-summary-of-security-hotspots","title":"10. Summary of Security Hotspots","text":"<p>Based on the analysis of the protocol specification, communication patterns, and trust boundaries, the following areas represent the most significant security risks and require careful mitigation:</p> <ol> <li> <p>Tool Execution (<code>tools/call</code>) - Arbitrary Code Execution Risk: This is inherently the highest-risk feature. Servers MUST implement rigorous input validation against the JSON schema, strong authorization checks, output sanitization, and consider sandboxing tool execution environments.</p> </li> <li> <p>User Consent &amp; Control (Client/Host Responsibility): The MCP specification explicitly relies on the client/host application to mediate user consent for potentially sensitive operations like <code>tools/call</code> and <code>sampling/createMessage</code>, as well as resource access. Failure to implement clear, explicit, and non-bypassable user confirmation flows breaks the security model.</p> </li> <li> <p>Resource Access (<code>resources/read</code>) - Path Traversal &amp; Access Control: Servers MUST perform strict validation and canonicalization of resource URIs provided by clients to prevent access to unauthorized files/data (e.g., path traversal). Authorization checks must occur before any resource access.</p> </li> <li> <p>Input Validation (Client &amp; Server): Both clients and servers MUST rigorously validate all parameters received in requests and notifications against expected types, formats, and constraints. This is crucial to prevent injection attacks (prompt injection, SQLi, command injection via tool args), DoS, and crashes. Special attention is needed for URIs, tool arguments, prompt arguments, and any data used to interact with external systems.</p> </li> <li> <p>Sampling (<code>sampling/createMessage</code>) - Prompt Injection &amp; Client Resource Abuse: Servers can provide prompt content (<code>messages</code>, <code>systemPrompt</code>) that might be used to attack the client's LLM (prompt injection). Malicious servers could also abuse the sampling feature to cause excessive cost or resource usage on the client side. Client-side user confirmation and rate limiting are essential.</p> </li> <li> <p>Authentication &amp; Authorization: Securely authenticating clients and servers (especially over HTTP using OAuth 2.1/PKCE as specified) and performing granular authorization checks on the server-side for all operations (resource access, tool calls, prompt access) are fundamental.</p> </li> <li> <p>Transport Security: Unencrypted communication channels (HTTP, WS, potentially stdio) expose all MCP messages to eavesdropping and tampering. HTTPS/WSS must be enforced for remote connections.</p> </li> <li> <p>Data Leakage (Logs, Errors, Responses): Sensitive information (credentials, PII, internal system details, private data from resources/external systems) MUST NOT be leaked through log messages (<code>notifications/message</code>), error responses (<code>error.data</code>, <code>error.message</code>), or normal operation results (<code>tools/call</code> content, <code>resources/read</code> content, etc.). Requires careful sanitization and filtering at the source.</p> </li> <li> <p>Server Interaction with External Systems: When servers access databases, APIs, or filesystems based on MCP requests, they MUST use secure practices like parameterized queries, credential management, and least privilege to prevent downstream vulnerabilities.</p> </li> <li> <p>Client-Side Handling of Received Content: Clients must treat content received from servers (resource <code>text</code>/<code>blob</code>, tool <code>content</code>, prompt <code>messages</code>) as potentially untrusted and handle/render it safely (e.g., sanitizing HTML/JS in resource content) to prevent XSS and other client-side attacks. </p> </li> </ol>"}]}